abstract class Command {
  /// The name of the command
  String command;
  String? use;

  /// Aliases that should work the same was as the provided command name
  List<String>? aliases;

  /// A description of the command, consider putting documentation here.
  String? description;

  /// An example of how to run the command.
  String? example;

  /// Any subcommands that belong under this command.
  List<Command>? subcommands;

  /// Any flags that are supported and a description of their purpose.
  /// Your command can leverage flags outside of the supported flags,
  /// but this provides a way to document what flags are available for
  /// autogenerated help text.
  Map<String, String>? supportedFlags;

  Command(
      {required this.command,
      this.use,
      this.aliases,
      this.description,
      this.example,
      this.subcommands,
      this.supportedFlags});

  /// Run defines what code should be ran when this command is executed.
  void run(List<String> args, Map<String, dynamic> flags);

  /// PreRun defines what code should be ran before the command is executed.
  /// Consider using this to set things up before the command is run.
  void preRun(List<String> args, Map<String, dynamic> flags) {}

  /// PostRun defines what code should be ran after the command is executed.
  /// Consider using this to clean up or free resources after the command is run.
  void postRun(List<String> args, Map<String, dynamic> flags) {}

  /// Returns a list of all possibly command names that this command should run from
  /// including the original name and all aliases
  List<String> getAllLogicalNames() {
    return [
      command,
      ...(aliases ?? []),
    ];
  }

  printHelp() {
    print('''
$command ${use ?? ''} ${aliases?.join('|') ?? ''}
${description ?? 'No description provided'}

example:
  ${example ?? 'No example provided'}

supported flags:''');
    supportedFlags?.forEach((key, value) {
      print('  $key: $value');
    });
  }
}

/// BosunCommand is the entry point into bosun from your application
/// Generally your main method for your CLI will create a BosunCommand passing
/// in your application name and any subcommands and then pass that to Bosun's
/// execute method to process and execute the command.
/// See the example folder in the Bosun repo for more information.
class BosunCommand extends Command {
  BosunCommand(String appName, {String description = '', required List<Command> subcommands})
      : super(command: appName, description: description, subcommands: subcommands);

  @override
  void run(List<String> args, Map<String, dynamic> flags) {
    // Intentionally left blank
  }
}
